#!/bin/bash

__usage__="usage: ${0} START END INCREMENT COMMAND [-v]

Loop over a range of dates (UTC) in steps increments of multiples of hours.

Positional arguments:

    START END
        Start and end timesteps, inclusive (YYYYMMDDHH[NN], i.e., %Y%m%d%H[%M]).

    INCREMENT
        Timestep increment in the smallest timestep unit, e.g., minutes for *%M.

    COMMAND
        The command executed for each timestep. To use the datetime components,
        add them as escaped variables (\$DATE, \$YYYY, \$MM, \$DD, \$HH, \$NN).

Optional arguments:

    -v [N=1]
        Print the current timestep for Nth iteration (N in [1..999]).

    -p N
        Parallelize over N processes at a time (N in [1..99]).
"
__debug__=false

# Set defaults
__verbose__=false

# Parse command line arguments
__n__=0
__num_procs__=1
__args__=("${@}")
for ((__i__ = 0; __i__ < ${#__args__[@]}; __i__++))
do
    __arg__=${__args__[__i__]}
    ${__debug__} && echo "${__i__} ${__arg__}" >&2
    case "${__arg__}" in
        "-v")
            __verbose__=true
            echo "${__args__[__i__+1]}" | grep -q '^[1-9][0-9]\{,2\}$'
            [ ${?} -eq 0 ] && { __i__=$((__i__+1)); __vb_n__=${__args__[__i__]}; } || __vb_n__=1
        ;;
        "-p")
            echo "${__args__[__i__+1]}" | grep -q '^[1-9][0-9]\?$'
            [ ${?} -ne 0 ] && { echo "'-p' not followed by number of processes" >&2; exit 4; }
            __i__=$((__i__+1))
            __num_procs__=${__args__[__i__]}
        ;;
        *)
            __n__=$((__n__+1))
            case "${__n__}" in
                1) __date_start__="${__arg__}" ;;
                2) __date_end__="${__arg__}" ;;
                3) __increment__="${__arg__}" ;;
                4) __cmd__="${__arg__}" ;;
            esac
        ;;
    esac
done
[ ${__n__} -ne 4 ] && { echo -e "error: wrong number of positional arguments: ${__n__}\n\n${__usage__}" >&2; exit 2; }

# Set timezone to UTC to avoid winter-/summertime change issues
export TZ=UTC

# Determine resolution based on start date length
case ${#__date_start__} in
    10) __res__=hour;;
    12) __res__=minute;;
    *)  echo "invalid start datetime ${__date_start__} string of length ${#__date_start__}" >&2
        exit 2
    ;;
esac

# Check dates and increment
if [ "${__res__}" == "hour" ]
then
    echo "${__date_start__}" | grep -q '[12][0-9]\{3\}[01][0-9][0-3][0-9][012][0-9]'
    err="invalid start date ${__date_start__} for length 10, expect format YYYYMMDDHH, i.e., %Y%m%d%H"
    [ $? -ne 0 ] && { echo "${err}" >&2; exit 2; }
    echo "${__date_end__}" | grep -q '[12][0-9]\{3\}[01][0-9][0-3][0-9][012][0-9]'
    err="invalid end date ${__date_end__} for length 10, expect format YYYYMMDDHH, i.e., %Y%m%d%H"
    [ $? -ne 0 ] && { echo "${err}" >&2; exit 2; }
elif [ "${__res__}" == "minute" ]
then
    echo "${__date_start__}" | grep -q '[12][0-9]\{3\}[01][0-9][0-3][0-9][012][0-9][0-5][0-9]'
    err="invalid start date ${__date_start__} for length 12, expect format YYYYMMDDHHNN, i.e., %Y%m%d%H%M"
    [ $? -ne 0 ] && { echo "${err}" >&2; exit 2; }
    echo "${__date_end__}" | grep -q '[12][0-9]\{3\}[01][0-9][0-3][0-9][012][0-9][0-5][0-9]'
    err="invalid end date ${__date_end__} for length 12, expect format YYYYMMDDHHNN, i.e., %Y%m%d%H%M"
    [ $? -ne 0 ] && { echo "${err}" >&2; exit 2; }
else
    echo "invalid start date ${__date_start__} of length ${#__date_start__}" >&2; exit 2
fi
err="invalid non-zero increment ${__increment__}"
[ ${__increment__} -eq 0 ] && { echo "${err}" >&2; exit 2; }

# Determine start date
case "${__res__}" in
    "hour"  ) __date_curr__="$(TZ=UTC date +%Y%m%d%H   -d "${__date_start__:0:8} ${__date_start__:8:2} - ${__increment__} hours")" ;;
    "minute") __date_curr__="$(TZ=UTC date +%Y%m%d%H%M -d "${__date_start__:0:8} ${__date_start__:8:4} - ${__increment__} minutes")" ;;
esac

# Loop over dates (dont use while loop to avoid infinite loop)
__pids_active__=()
__dates_active__=()
__iter_max__=$((__date_end__ - __date_start__)) # bigger than actual number of iterations
for iter_i in $(seq 0 ${__iter_max__})
do
    # Increment date
    case "${__res__}" in
        "hour"  ) __date_curr__="$(TZ=UTC date +%Y%m%d%H   -d "${__date_curr__:0:8} ${__date_curr__:8:2} + ${__increment__} hours")";;
        "minute") __date_curr__="$(TZ=UTC date +%Y%m%d%H%M -d "${__date_curr__:0:8} ${__date_curr__:8:4} + ${__increment__} minutes")";;
    esac

    # Are we done yet?
    [ ${__date_curr__} -gt ${__date_end__} ] && break

    # Define variables to access the datetime components
    DATE="${__date_curr__}"
    YYYY="${__date_curr__:0:4}"
    MM="${__date_curr__:4:2}"
    DD="${__date_curr__:6:2}"
    HH="${__date_curr__:8:2}"
    NN="${__date_curr__:10:2}"

    # Print current timestep if requested
    ${__verbose__} && [ $((iter_i%__vb_n__)) -eq 0 ] && echo "${__date_curr__}"

    # Execute command
    eval ${__cmd__} &
    __pids_active__[iter_i%__num_procs__]=${!}
    __dates_active__[iter_i%__num_procs__]=${__date_curr__}

    # Once N processes have been started in the background,
    # wait for them to finish before starting new ones
    # For sequential execution, this is simply done every timestep
    if [ $(((iter_i+1)%__num_procs__)) -eq 0 ]
    then
        # Wait in turn for each active process
        # Count the number of failed processes
        # Even if one fails, the others can finish
        __nerr__=0
        __stats__=()
        for (( __i__=0; __i__<${__num_procs__}; __i__++ ))
        do
            __pid__=${__pids_active__[__i__]}
            __date__=${__dates_active__[__i__]}
            wait ${__pid__}
            __stat__=${?}
            __stats__[__i__]=${__stat__}
            [ ${__stat__} -ne 0 ] && __nerr__=$((__nerr__ + 1))
        done

        # Just in case
        wait

        # In case of failed processes, abort execution
        if [ ${__nerr__} -gt 0 ]
        then
            __ierr__=0
            for (( __i__=0; __i__<${__num_procs__}; __i__++ ))
            do
                __pid__=${__pids_active__[__i__]}
                __date__=${__dates_active__[__i__]}
                __stat__=${__stats__[__i__]}
                echo -n " $((__i__+1))/${__num_procs__} [${__pid__}] "
                if [ ${__stat__} -eq 0 ]
                then
                    echo "OK ${__date__}" >&2
                else
                    echo "ERROR $((__ierr__+1))/${__nerr__} (${__stat__}) ${__date__}" >&2
                    __ierr__=$((__ierr__+1))
                fi
            done
            exit ${__nerr__}
        fi
    fi
done

# Just in case
wait

