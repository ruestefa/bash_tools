#!/bin/bash

usage="usage: $0 START END INCREMENT COMMAND [-v]

Loop over a range of dates (UTC) in steps increments of multiples of hours.

Positional arguments:

    START END
        Start and end timesteps, inclusive (YYYYMMDDHH[NN], i.e., %Y%m%d%H[%M]).

    INCREMENT
        Timestep increment in the smallest timestep unit, e.g., minutes for *%M.

    COMMAND
        The command executed for each timestep. To use the datetime components,
        add them as escaped variables (\$DATE, \$YYYY, \$MM, \$DD, \$HH, \$NN).

Optional arguments:

    -v [N=1]
        Print the current timestep for Nth iteration (N in [1..999]).

    -p N
        Parallelize over N processes at a time (N in [1..99]).
"
debug=false

# Set defaults
verbose=false

# Parse command line arguments
i=0
n=0
num_procs=1
args=("${@}")
for ((i = 0; i < ${#args[@]}; i++))
do
    arg=${args[i]}
    $debug && echo "${i} ${arg}" >&2
    case "${arg}" in
        "-v")
            verbose=true
            echo "${args[i+1]}" | grep -q '^[1-9][0-9]\{,2\}$'
            [ ${?} -eq 0 ] && { i=$((i+1)); vb_n=${args[i]}; } || vb_n=1
        ;;
        "-p")
            echo "${args[i+1]}" | grep -q '^[1-9][0-9]\?$'
            [ ${?} -ne 0 ] && { echo "'-p' not followed by number of processes" >&2; exit 4; }
            i=$((i+1))
            num_procs=${args[i]}
        ;;
        *)
            n=$((n+1))
            case "${n}" in
                1) date_start="${arg}" ;;
                2) date_end="${arg}" ;;
                3) increment="${arg}" ;;
                4) cmd="${arg}" ;;
            esac
        ;;
    esac
done
[ ${n} -ne 4 ] && { echo -e "error: wrong number of positional arguments: ${n}\n\n${usage}" >&2; exit 2; }

# Set timezone to UTC to avoid winter-/summertime change issues
export TZ=UTC

# Determine resolution based on start date length
case ${#date_start} in
    10) res=hour;;
    12) res=minute;;
    *)  echo "invalid start datetime ${date_start} string of length ${#date_start}" >&2
        exit 2
    ;;
esac

# Check dates and increment
if [ "${res}" == "hour" ]
then
    echo "${date_start}" | grep -q '[12][0-9]\{3\}[01][0-9][0-3][0-9][012][0-9]'
    err="invalid start date ${date_start} for length 10, expect format YYYYMMDDHH, i.e., %Y%m%d%H"
    [ $? -ne 0 ] && { echo "${err}" >&2; exit 2; }
    echo "${date_end}" | grep -q '[12][0-9]\{3\}[01][0-9][0-3][0-9][012][0-9]'
    err="invalid end date ${date_end} for length 10, expect format YYYYMMDDHH, i.e., %Y%m%d%H"
    [ $? -ne 0 ] && { echo "${err}" >&2; exit 2; }
elif [ "${res}" == "minute" ]
then
    echo "${date_start}" | grep -q '[12][0-9]\{3\}[01][0-9][0-3][0-9][012][0-9][0-5][0-9]'
    err="invalid start date ${date_start} for length 12, expect format YYYYMMDDHHNN, i.e., %Y%m%d%H%M"
    [ $? -ne 0 ] && { echo "${err}" >&2; exit 2; }
    echo "${date_end}" | grep -q '[12][0-9]\{3\}[01][0-9][0-3][0-9][012][0-9][0-5][0-9]'
    err="invalid end date ${date_end} for length 12, expect format YYYYMMDDHHNN, i.e., %Y%m%d%H%M"
    [ $? -ne 0 ] && { echo "${err}" >&2; exit 2; }
else
    echo "invalid start date ${date_start} of length ${#date_start}" >&2; exit 2
fi
err="invalid non-zero increment ${increment}"
[ ${increment} -eq 0 ] && { echo "${err}" >&2; exit 2; }

# Determine start date
case "${res}" in
    "hour"  ) date_curr="$(TZ=UTC date +%Y%m%d%H   -d "${date_start:0:8} ${date_start:8:2} - ${increment} hours")" ;;
    "minute") date_curr="$(TZ=UTC date +%Y%m%d%H%M -d "${date_start:0:8} ${date_start:8:4} - ${increment} minutes")" ;;
esac

# Loop over dates (dont use while loop to avoid infinite loop)
pids_active=()
dates_active=()
iter_max=$((date_end - date_start)) # bigger than actual number of iterations
for iter_i in $(seq 0 $iter_max)
do
    # Increment date
    case "${res}" in
        "hour"  ) date_curr="$(TZ=UTC date +%Y%m%d%H   -d "${date_curr:0:8} ${date_curr:8:2} + ${increment} hours")";;
        "minute") date_curr="$(TZ=UTC date +%Y%m%d%H%M -d "${date_curr:0:8} ${date_curr:8:4} + ${increment} minutes")";;
    esac
    yyyy="${date_curr:0:4}"
    mm="${date_curr:4:2}"
    dd="${date_curr:6:2}"
    hh="${date_curr:8:2}"
    nn="${date_curr:10:2}"

    # Are we done yet?
    [ ${date_curr} -gt ${date_end} ] && break

    # Insert date components in comment
    cmd_i="$(echo ${cmd} | sed \
            -e "s/\${\?DATE}\?/${date_curr}/g" \
            -e "s/\${\?YYYY}\?/${yyyy}/g" \
            -e "s/\${\?MM}\?/${mm}/g" \
            -e "s/\${\?DD}\?/${dd}/g" \
            -e "s/\${\?HH}\?/${hh}/g" \
            -e "s/\${\?NN}\?/${nn}/g")"

    # Print current timestep if requested
    ${verbose} && [ $((iter_i%vb_n)) -eq 0 ] && echo "${date_curr}"

    # Execute command
    eval ${cmd_i} &
    pids_active[iter_i%num_procs]=${!}
    dates_active[iter_i%num_procs]=${date_curr}

    # Once N processes have been started in the background,
    # wait for them to finish before starting new ones
    # For sequential execution, this is simply done every timestep
    if [ $(((iter_i+1)%num_procs)) -eq 0 ]
    then
        # Wait in turn for each active process
        # Count the number of failed processes
        # Even if one fails, the others can finish
        nerr=0
        stats=()
        for (( i=0; i<${num_procs}; i++ ))
        do
            pid=${pids_active[i]}
            date=${dates_active[i]}
            wait ${pid}
            stat=${?}
            stats[i]=${stat}
            [ ${stat} -ne 0 ] && nerr=$((nerr + 1))
        done
        pics_active=()

        # Just in case
        wait

        # In case of failed processes, abort execution
        if [ ${nerr} -gt 0 ]
        then
            for (( i=0; i<${num_procs}; i++ ))
            do
                pid=${pids_active[i]}
                date=${dates_active[i]}
                stat=${stats[i]}
                if [ ${stat} -eq 0 ]
                then
                    echo "[${pid}] OK ${date}" >&2
                else
                    echo "[${pid}] ERROR ${stat} ($((i+1))/${num_procs}) ${date}" >&2
                fi
            done
            echo " ABORT ${nerr}/${num_procs}" >&2
            exit ${nerr}
        fi
    fi
done

# Just in case
wait

